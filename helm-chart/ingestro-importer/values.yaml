nameOverride: ""
fullnameOverride: ""

# DNS suffix used for in-cluster service discovery.
clusterDomain: cluster.local

global:
  imagePullSecrets: []
  imageCredentials:
    name: "" # Optional override for the Kubernetes Secret name
    create: false # Set to true to render a Secret from the inline credentials
    registry: https://index.docker.io/v1/
    username: getnuvo
    password: "" # Replace with your Docker Hub password when create=true
    email: "" # Optional registry e-mail address
    externalSecret:
      enabled: false
      name: "" # Name of the ExternalSecret resource (defaults to <release>-registry-external)
      refreshInterval: 1h
      secretStoreRef:
        name: "" # Required when enabled
        kind: ClusterSecretStore
      target:
        name: "" # Defaults to the managed image pull secret name
        creationPolicy: Owner
        deletionPolicy: ""
      data: [] # Provide entries that populate the .dockerconfigjson key
      dataFrom: [] # Optional extract/find operations
  licenseKey: "" # replace with your Ingestro license key
  podAnnotations: {}
  extraLabels: {}

tests:
  health:
    image:
      repository: curlimages/curl
      tag: "8.11.1"
      pullPolicy: IfNotPresent

importer:
  enabled: true
  replicaCount: 1

  image:
    repository: getnuvo/importer
    tag: 1.2.1 # Always check the latest tag in the repository
    pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    name: ""
    annotations: {}

  podAnnotations: {}
  podLabels: {}
  podSecurityContext: {}
  securityContext: {}

  service:
    type: ClusterIP
    port: 3000
    extraPorts: []

  env:
    IMPORTER_DB_HOST: "" # Keep empty to use the default MongoDB service name
    IMPORTER_DB_NAME: nuvo # Keep the default database name
    IMPORTER_DB_USERNAME: admin # Currently using the default database username
    IMPORTER_DB_PASSWORD: admin # Currently using the default database password
    IMPORTER_PORT: "3000" # Keep the default port

  secrets:
    IMPORTER_LICENSE_KEY: "" # Keep empty to use the global license key
    IMPORTER_AWS_ACCESS_KEY: "" # Replace with your AWS access key
    IMPORTER_AWS_SECRET_KEY: "" # Replace with your AWS secret key
    IMPORTER_AWS_REGION: "" # Replace with your AWS region
    IMPORTER_AWS_S3_BUCKET: "" # Replace with your AWS S3 bucket name

  secretRef:
    existingSecret: "" # Reference an existing Kubernetes Secret instead of creating one

  externalSecret:
    enabled: false
    name: "" # Name of the ExternalSecret resource (defaults to <release>-...-secret-external)
    refreshInterval: 1h
    secretStoreRef:
      name: "" # Required when enabled
      kind: ClusterSecretStore
    target:
      name: "" # Target secret name (defaults to the standard component secret name)
      creationPolicy: Owner
      deletionPolicy: ""
    data: [] # List of secretKey/remoteRef entries
    dataFrom: [] # Optional entries for extract/find operations

  extraEnv: []
  extraEnvFrom: []

  livenessProbe:
    enabled: true
    httpGet:
      path: /sdk/v1/health
      port: http
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 6

  readinessProbe:
    enabled: true
    httpGet:
      path: /sdk/v1/health
      port: http
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 6

  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  volumes: []
  volumeMounts: []

  autoscaling:
    enabled: false
    minReplicas: 2
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: null

  pdb:
    enabled: false
    minAvailable: 1
    maxUnavailable: null

mapping:
  enabled: true
  replicaCount: 1

  image:
    repository: getnuvo/mapping
    tag: 1.1.5 # Always check the latest tag in the repository
    pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    name: ""
    annotations: {}

  podAnnotations: {}
  podLabels: {}
  podSecurityContext: {}
  securityContext: {}

  service:
    type: ClusterIP
    port: 3001

  env:
    MAPPING_PORT: "3001" # Keep the default port
    MAPPING_LLM_PROVIDER: "" # Leave empty to disable; set to AZURE_OPENAI, AWS_BEDROCK, GCP_VERTEX, or OPENAI to enable
    MAPPING_LLM_TEMPERATURE: "0.7" # Change this value to adjust the temperature of the LLM

  secrets:
    MAPPING_LICENSE_KEY: "" # Keep empty to use the global license key
    MAPPING_AWS_BEDROCK_ACCESS_KEY_ID: "" # Optional: leave empty to use IAM role auth for Bedrock
    MAPPING_AWS_BEDROCK_MODEL_ID: "" # Replace with your AWS Bedrock model ID
    MAPPING_AWS_BEDROCK_REGION: "" # Replace with your AWS Bedrock region
    MAPPING_AWS_BEDROCK_SECRET_ACCESS_KEY: "" # Optional: leave empty to use IAM role auth for Bedrock
    MAPPING_AZURE_OPENAI_API_KEY: "" # Replace with your Azure OpenAI API key
    MAPPING_AZURE_OPENAI_API_VERSION: "" # Replace with your Azure OpenAI API version
    MAPPING_AZURE_OPENAI_DEPLOYMENT_NAME: "" # Replace with your Azure OpenAI deployment name
    MAPPING_AZURE_OPENAI_ENDPOINT: "" # Replace with your Azure OpenAI endpoint
    MAPPING_GCP_VERTEX_CREDENTIALS_JSON: "" # Replace with your GCP service account JSON (within single quotation marks)
    MAPPING_GCP_VERTEX_PROJECT_ID: "" # Replace with your GCP project ID
    MAPPING_GCP_VERTEX_LOCATION: "" # Replace with your GCP Vertex location
    MAPPING_GCP_VERTEX_MODEL_ID: "" # Replace with your GCP Vertex model ID
    MAPPING_OPENAI_API_KEY: "" # Replace with your OpenAI API key
    MAPPING_OPENAI_MODEL: "" # Replace with your OpenAI model

  secretRef:
    existingSecret: "" # Reference an existing Kubernetes Secret instead of creating one

  externalSecret:
    enabled: false
    name: ""
    refreshInterval: 1h
    secretStoreRef:
      name: ""
      kind: ClusterSecretStore
    target:
      name: ""
      creationPolicy: Owner
      deletionPolicy: ""
    data: []
    dataFrom: []

  extraEnv: []
  extraEnvFrom: []

  livenessProbe:
    enabled: true
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 6

  readinessProbe:
    enabled: true
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 6

  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  volumes: []
  volumeMounts: []

  autoscaling:
    enabled: false
    minReplicas: 2
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: null

  pdb:
    enabled: false
    minAvailable: 1
    maxUnavailable: null

aiService:
  enabled: true
  replicaCount: 1

  image:
    repository: getnuvo/service
    tag: 0.0.2 # Always check the latest tag in the repository
    pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    name: ""
    annotations: {}

  podAnnotations: {}
  podLabels: {}
  podSecurityContext: {}
  securityContext: {}

  service:
    type: ClusterIP
    port: 3002

  env:
    SERVICE_PORT: "3002" # Keep the default port

  secrets:
    SERVICE_LICENSE_KEY: "" # Keep empty to use the global license key
    CLEANING_ASSISTANT_AWS_BEDROCK_ACCESS_KEY_ID: "" # Optional: leave empty to use IAM role auth for Bedrock
    CLEANING_ASSISTANT_AWS_BEDROCK_MODEL_ID: "" # Replace with your AWS Bedrock model ID
    CLEANING_ASSISTANT_AWS_BEDROCK_REGION: "" # Replace with your AWS Bedrock region
    CLEANING_ASSISTANT_AWS_BEDROCK_SECRET_ACCESS_KEY: "" # Optional: leave empty to use IAM role auth for Bedrock
    CLEANING_ASSISTANT_AZURE_OPENAI_API_KEY: "" # Replace with your Azure OpenAI API key
    CLEANING_ASSISTANT_AZURE_OPENAI_API_VERSION: "" # Replace with your Azure OpenAI API version
    CLEANING_ASSISTANT_AZURE_OPENAI_DEPLOYMENT_NAME: "" # Replace with your Azure OpenAI deployment name
    CLEANING_ASSISTANT_AZURE_OPENAI_ENDPOINT: "" # Replace with your Azure OpenAI endpoint
    CLEANING_ASSISTANT_LLM_PROVIDER: BEDROCK # Replace with your LLM provider: AZURE or BEDROCK
    CLEANING_ASSISTANT_TEMPERATURE: "0.7" # Change this value to adjust the temperature of the LLM
    CONTEXTUAL_ENGINE_AWS_BEDROCK_ACCESS_KEY_ID: "" # Optional: leave empty to use IAM role auth for Bedrock
    CONTEXTUAL_ENGINE_AWS_BEDROCK_MODEL_ID: "" # Replace with your AWS Bedrock model ID
    CONTEXTUAL_ENGINE_AWS_BEDROCK_REGION: "" # Replace with your AWS Bedrock region
    CONTEXTUAL_ENGINE_AWS_BEDROCK_SECRET_ACCESS_KEY: "" # Optional: leave empty to use IAM role auth for Bedrock
    CONTEXTUAL_ENGINE_AZURE_OPENAI_API_KEY: "" # Replace with your Azure OpenAI API key
    CONTEXTUAL_ENGINE_AZURE_OPENAI_API_VERSION: "" # Replace with your Azure OpenAI API version
    CONTEXTUAL_ENGINE_AZURE_OPENAI_DEPLOYMENT_NAME: "" # Replace with your Azure OpenAI deployment name
    CONTEXTUAL_ENGINE_AZURE_OPENAI_ENDPOINT: "" # Replace with your Azure OpenAI endpoint
    CONTEXTUAL_ENGINE_LLM_PROVIDER: BEDROCK # Replace with your LLM provider: AZURE or BEDROCK
    CONTEXTUAL_ENGINE_TEMPERATURE: "0.7" # Change this value to adjust the temperature of the LLM
    TEXT_TO_JS_AWS_BEDROCK_ACCESS_KEY_ID: "" # Optional: leave empty to use IAM role auth for Bedrock
    TEXT_TO_JS_AWS_BEDROCK_MODEL_ID: "" # Replace with your AWS Bedrock model ID
    TEXT_TO_JS_AWS_BEDROCK_REGION: "" # Replace with your AWS Bedrock region
    TEXT_TO_JS_AWS_BEDROCK_SECRET_ACCESS_KEY: "" # Optional: leave empty to use IAM role auth for Bedrock
    TEXT_TO_JS_AZURE_OPENAI_API_KEY: "" # Replace with your Azure OpenAI API key
    TEXT_TO_JS_AZURE_OPENAI_API_VERSION: "" # Replace with your Azure OpenAI API version
    TEXT_TO_JS_AZURE_OPENAI_DEPLOYMENT_NAME: "" # Replace with your Azure OpenAI deployment name
    TEXT_TO_JS_AZURE_OPENAI_ENDPOINT: "" # Replace with your Azure OpenAI endpoint
    TEXT_TO_JS_LLM_PROVIDER: BEDROCK # Replace with your LLM provider: AZURE or BEDROCK
    TEXT_TO_JS_TEMPERATURE: "0.7" # Change this value to adjust the temperature of the LLM

  secretRef:
    existingSecret: "" # Reference an existing Kubernetes Secret instead of creating one

  externalSecret:
    enabled: false
    name: ""
    refreshInterval: 1h
    secretStoreRef:
      name: ""
      kind: ClusterSecretStore
    target:
      name: ""
      creationPolicy: Owner
      deletionPolicy: ""
    data: []
    dataFrom: []

  extraEnv: []
  extraEnvFrom: []

  livenessProbe:
    enabled: true
    httpGet:
      path: /sdk/service/health
      port: http
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 6

  readinessProbe:
    enabled: true
    httpGet:
      path: /sdk/service/health
      port: http
    initialDelaySeconds: 30
    timeoutSeconds: 5
    periodSeconds: 10
    failureThreshold: 6

  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  volumes: []
  volumeMounts: []

  autoscaling:
    enabled: false
    minReplicas: 2
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: null

  pdb:
    enabled: false
    minAvailable: 1
    maxUnavailable: null

mongo:
  enabled: true

  image:
    repository: mongo
    tag: 7.0
    pullPolicy: IfNotPresent

  replicaCount: 1

  podAnnotations: {}
  podLabels: {}
  podSecurityContext: {}
  securityContext: {}

  auth:
    rootUsername: admin
    rootPassword: admin

  persistence:
    enabled: true
    accessModes:
      - ReadWriteOnce
    size: 10Gi
    storageClass: ""

  service:
    type: ClusterIP
    port: 27017

  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}

gateway:
  enabled: true
  className: nginx
  annotations: {}
  cors:
    enable: true
    allowOrigin: "*"
    allowMethods: "GET,POST,PUT,DELETE,OPTIONS"
    allowHeaders: "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization"
    allowCredentials: "true"
  tls: []
  hosts:
    - host: importer.local # Replace with your hostname.
      paths:
        - path: /sdk/v1
          pathType: Prefix
          service:
            name: importer
            port: http
        - path: /sdk/service
          pathType: Prefix
          service:
            name: aiservice
            port: http
mappingGateway:
  enabled: true
  className: nginx
  annotations: {}
  cors:
    enable: true
    allowOrigin: "*"
    allowMethods: "GET,POST,PUT,DELETE,OPTIONS"
    allowHeaders: "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization"
    allowCredentials: "true"
  hosts:
    - host: importer.local # Replace with your hostname
      paths:
        - path: /sdk/mapping/health
          pathType: Prefix
          rewriteTarget: /health
          service:
            name: mapping
            port: http
        - path: /sdk/mapping/(v1/.*)
          pathType: ImplementationSpecific
          useRegex: true
          rewriteTarget: /$1
          service:
            name: mapping
            port: http
